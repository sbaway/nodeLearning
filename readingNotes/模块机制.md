## 模块机制 ##

JavaScript缺乏“模块”功能，只能通过 `<script>` 标签引入代码，语言自身没有组织能力。Node通过引入CommonJS规范很好地解决了这个问题。

### 一、 CommonJS规范 ###

CommonJS规范的提出，弥补了JavaScript自身语言的缺陷：

- 没有模块系统
- 标准库较少，没有文件系统、I/O流等常见需求的API
- 没有标准接口，没有定义与Web服务器或数据库的统一接口
- 缺乏包管理系统

#### CommonJS的模块规范 ####

CommonJS对模块的定义主要分为：模块引用、模块定义、模块标识3个部分。

##### 1. 模块引用 #####

运用 `require()` 方法接收一个模块标识，以此引入一个模块的API到当前上下文中。

##### 2. 模块定义 #####

运用 `exports` 对象导出当前模块的方法或者变量。

##### 3. 模块标识 #####

模块标识就是传给 `require()` 方法的参数，它可以是以下几种形式：

- 符合小驼峰命名的字符串
- 以.、..开头的相对路径
- 以/开头的绝对路径

### 二、 Node模块的实现 ###

在Node中，模块分为两类：

- 核心模块： Node提供的模块
- 文件模块： 用户编写的模块

在Node中引入模块要经历以下3个步骤：

1. 路径分析
2. 文件定位
3. 编译执行

核心模块部分在Node进程启动时，就直接加载进内存中，所以核心模块引入时可以省略前两个步骤，直接编译执行。核心模块比文件模块加载更快。

#### 路径分析和文件定位 ####

##### 1. 模块标识符分析 #####

- 核心模块
  
    核心模块优先级仅次于缓存加载，其加载速度最快。如果试图加载一个与核心模块同名的文件模块是不会成功的。

- 路径形式的文件模块

    以.、..和/开始的标识符都被当做文件模块来处理。`require()` 方式会将路径转换成真实路径查找文件后加载。

- 自定义模块

    自定义模块根据模块路径规则查找模块。模块路径的生成规则如下：

    1. 当前文件目录下的node_modules目录
    2. 父目录下的node_modules目录
    3. 父目录的父目录下的node_modules目录
    4. 沿路径向上逐级递归，直到根目录下的node_modules目录

##### 2. 文件定位 #####

在文件定位过程中，有一些需要注意的细节：文件扩展名的分析、目录和包的处理。

- 文件扩展名分析

    CommonJS模块规范允许标识符中不包含扩展名，这种情况下，Node会按.js、.node、.json的次序补足扩展名，依次尝试。

- 目录分析和包

    如果 `require()` 通过分析文件扩展名后没有发现对应的文件，却找到一个目录，那么Node会把它当做一个包来处理。

##### 3. 模块编译 #####

Node对JavaScript文件的编译过程中，对其内容进行了头尾包装。在头部添加了 `(function(exports, require, module, _filename, _dirname) {\n` ，在尾部添加了 `\n})`。这样每个模块文件之间都进行了作用域隔离。而且每个模块中都包含 `exports` 、 `require` 、 `module`这三个对象。

### 三、 包与NPM ###

包和NPM是将模块联系起来的机制。

#### 包结构 ####

完全符合CommonJS规范的包结构应该包含以下文件：

- package.json: 包描述文件
- bin: 用于存放可执行二进制文件的目录
- lib: 用于存放JavaScript代码的目录
- doc: 用于存放文档的目录
- test: 用于存放单元测试用例的代码

#### 包描述文件与NPM ####

包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。
package.json是一个JSON格式的文件，成为包描述文件。其中包含name, description, version, dependencies等字段，NPM的所有行为都与这些字段息息相关。

### 四、 前后端共用模块 ###

Node模块的引入过程几乎都是同步的，因为它从磁盘中加载，速度很快，而浏览器端的JavaScript代码需要通过网络加载，如果还是用同步的方式加载文件会花费很多等待的时间，所以浏览器端的JavaScript代码不能继续用CommonJS规范实现模块化，更好的方式是用AMD或CMD规范。它们都是异步加载模块的。




