## 异步I/O ##

**异步I/O**、**事件驱动**、**单线程**构成了Node的基调。

单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型会引起编程中的死锁、状态同步等问题。Node在两者之间给出了更优的方案：利用单线程和异步I/O。

异步I/O的提出是期望I/O的调用不再阻塞后续运算，将原有等待I/O完成的时间分配给其他业务执行。

### 一、异步I/O与非阻塞I/O ###

操作系统内核对于I/O只有两种方式：阻塞与非阻塞。这里的非阻塞I/O并非等同于异步I/O。

#### 1. 阻塞I/O ####

阻塞I/O是指在调用后应用程序要等待系统内核完成所有操作，调用才结束。这期间CPU需要一直等待，浪费时间和资源。

#### 2. 非阻塞I/O ####

非阻塞I/O跟阻塞I/O的区别是它在调用后会立即返回，不需要等待内核完成操作返回数据。

但是由于完整的I/O并没有完成，返回的不是期望的数据，而是当前调用的状态，所以应用程序需要通过**轮询**的方式判断操作是否完成。轮询也是对CPU资源的浪费，因为这期间CPU不是在遍历文件描述符的状态，就是在休眠等待事件发生。

### 二、 Node的异步I/O ###

理想状态下期望的异步I/O应该是应用程序发起调用，然后就可以直接处理下个任务，只需在I/O完成后通过信号或回调来接收数据。

Node是通过另外开启I/O线程来实现这一效果的。让部分线程进行I/O处理，另一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递。

#### 1. 事件循环 ####

Node进程启动时，会创建一个类似于while的循环，每次循环称为Tick。Tick检查是否有待处理事件，如果有就取出事件及相应的回调函数，并执行。

#### 2. 观察者 ####

在事件循环中，要通过观察者来判断是否有待处理的事件。

#### 3. 请求对象 ####

从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一个中间产物：请求对象。

Node中进行异步I/O调用的过程一般是这样的： JavaScript调用Node核心模块 -> 核心模块调用C++内建模块 -> 内建模块通过libuv进行系统调用。在进行系统调用的过程中，会创建一个请求对象，JavaScript层传入的参数、当前方法和回调函数都被封装在这个对象中。然后将对象推入线程池等待执行。当线程池中有可用线程时，会调用其中的方法。

至此，JavaScript调用立即返回，发起异步调用的第一个阶段结束，JavaScript线程可以继续执行后续任务。

请求对象是异步I/O过程中的重要产物，所有状态都保存在这个对象中，包括送入线程池等待执行及I/O操作完毕后的回调处理。

#### 4. 执行回调 ####

回调通知是异步I/O的第二阶段。

线程池中的I/O操作完毕后会存储结果，并通知IOCP。而IOCP每次事件循环都会检查线程池中是否有执行玩的请求，如果有就将请求对象加入到观察者队列中，然后将其当做事件处理。

至此，整个异步I/O流程就完全结束了。



